// C:\important\quiet\n\mimita-public\mimita-public\src\physics\collision-capsule-triangle.cpp
// dec 16 2025
/**
 * purpose
 * this has all the SB that we dont want in the phsics cpp file 
 * so phsics just calls the functions 
 * and its all nice and readable 
 */

#include "collision-capsule-triangle.h"
#include "physics/config.h"
#include <glm/glm.hpp>
#include <algorithm>
#include <cstdio>

// ----------------------------
// Helpers
// ----------------------------

static glm::vec3 closestPointOnSegment(
    const glm::vec3& p,
    const glm::vec3& a,
    const glm::vec3& b)
{
    glm::vec3 ab = b - a;
    float t = glm::dot(p - a, ab) / glm::dot(ab, ab);
    t = glm::clamp(t, 0.0f, 1.0f);
    return a + ab * t;
}

static glm::vec3 closestPointOnTriangle(
    const glm::vec3& p,
    const Triangle& t)
{
    // Ericson â€“ Real-Time Collision Detection

    glm::vec3 ab = t.b - t.a;
    glm::vec3 ac = t.c - t.a;
    glm::vec3 ap = p - t.a;

    float d1 = glm::dot(ab, ap);
    float d2 = glm::dot(ac, ap);
    if (d1 <= 0.0f && d2 <= 0.0f) return t.a;

    glm::vec3 bp = p - t.b;
    float d3 = glm::dot(ab, bp);
    float d4 = glm::dot(ac, bp);
    if (d3 >= 0.0f && d4 <= d3) return t.b;

    float vc = d1*d4 - d3*d2;
    if (vc <= 0.0f && d1 >= 0.0f && d3 <= 0.0f)
    {
        float v = d1 / (d1 - d3);
        return t.a + v * ab;
    }

    glm::vec3 cp = p - t.c;
    float d5 = glm::dot(ab, cp);
    float d6 = glm::dot(ac, cp);
    if (d6 >= 0.0f && d5 <= d6) return t.c;

    float vb = d5*d2 - d1*d6;
    if (vb <= 0.0f && d2 >= 0.0f && d6 <= 0.0f)
    {
        float w = d2 / (d2 - d6);
        return t.a + w * ac;
    }

    float va = d3*d6 - d5*d4;
    if (va <= 0.0f && (d4 - d3) >= 0.0f && (d5 - d6) >= 0.0f)
    {
        float w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
        return t.b + w * (t.c - t.b);
    }

    float denom = 1.0f / (va + vb + vc);
    float v = vb * denom;
    float w = vc * denom;
    return t.a + ab * v + ac * w;
}

// ----------------------------
// collision 
// a hotly debated topic 
// 1. NO snap out. prvention only. prevent them from going in at all 
// 1.1. if they do go inside snap out 
// but literally 99% of the time just dont let them go in at all
// with a little bias toward the out direction so its not just equal to dist inside
// ----------------------------

glm::vec3 collideCapsuleTriangleMove(
    const Capsule& cap,
    const glm::vec3& move,
    const Triangle& tri,
    bool& onGround)
{
    // Triangle normal
    glm::vec3 n = glm::normalize(
        glm::cross(tri.b - tri.a, tri.c - tri.a)
    );

    // Ignore upside-down triangles
    // if (n.y <= 0.0f)
    // ignore sometihng else idk what this is 
    if (glm::length(n) < 0.0001f)
        return move;

    // Capsule bottom
    glm::vec3 foot = cap.a;
    glm::vec3 closest = closestPointOnTriangle(foot, tri);

    glm::vec3 delta = foot - closest;
    float dist = glm::length(delta);

    if (dist > cap.r)
        return move;

    if (move.y >= 0.0f)
        return move;

    onGround = true;

    printf("[COLLISION] ground hit\n");

    glm::vec3 out = move;
    out.y = 0.0f;
    return out;
}
